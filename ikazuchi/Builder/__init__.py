# ikazuchi 1.0
#
# (c) 2017, riidefi

from DirUtil import require_dir
from DirUtil import fmt_gath

SOURCE_PATH   = "./source/"
ASM_TEXT_PATH = "./asm/text/"
BUILD_PATH 	  = "./build/"
CWCC_OLD = True
CWCC_PATH 	  = ".\\tools\\OLD_mwcceppc.exe" if CWCC_OLD else ".\\tools\\mwcceppc.exe"
CWCC_OPT = " ".join([
	"-nodefaults",
	"-align powerpc",
	"-enc SJIS",
	"-c",
	# "-I-",
	"-gccinc",
	"-i ./source/",
	# "-inline deferred",
	"-proc gekko",
	"-enum int",
	"-O4,s",
	"-inline auto",
	"-W all",
	"-fp hardware",
	"-Cpp_exceptions off",
	"-RTTI off",
	"-pragma \"cats off\"", # ???
	# "-pragma \"aggressive_inline on\"",
	# "-pragma \"auto_inline on\"",	
	"-ipa file",
	"-inline auto",
	"-w notinlined -W noimplicitconv",
	"-nostdinc",
	"-msgstyle gcc -lang=c99 -DGALAXY -Isource\\WiiCore\\include"
])

def compile_source(src, dst):
	command = f"{CWCC_PATH} {CWCC_OPT if 'rx' not in src else CWCC_OPT.replace(',s', ',p')} {src} -o {dst}"
	print(command)
	os.system(command + " > ./tmp/compiler_log.txt")
	print(open("./tmp/compiler_log.txt").read().replace("source\\", ""))


def build_source(dest, source, listing, hash_manager):
	"""
	Compile over respective assembly file
	Remove assembly file hash from manager, force it to rebuild next time (optional?)
	"""



	# Compile over respective assembly file
	dst_path = ""
	for entry in listing:
		if entry[0] == dest:
			dst_path = BUILD_PATH + fmt_gath(entry[1])
			hash_manager.invalidate(entry[0])
	assert dst_path


	print(f"Compile to {dst_path}")
	compile_source(source, dst_path)

def build_sources(listing, hash_manager, sources, verbose=False):
	print("Generating linker script...")
	# Read build.lcf
	build_lcf = "// This is an autogenerated file. Edit build.lcf instead.\n\n\n" + open("./cfg/build.lcf", 'r').read()
	# Append force files

	build_lcf += "\nFORCEFILES {\n"
	for src in sources:
		x = ""
		for entry in listing:
			if entry[0] == src[1]:
				print(entry)
				build_lcf += f"\t\t{fmt_gath(entry[1])}\n"
				break
	build_lcf += "}\n"
	

	# save to ./shinobu/build_TMP.lcf
	#require_dir('tmp')
	with open("./cfg/build_TMP.lcf", 'w') as file:
		file.write(build_lcf)

	print("Building Sources...")
	for source in sources:
		print(f"Replacing {source[1]} with {source[0]}")
		build_source(source[1], source[0], listing, hash_manager)

import Assembler
from DirUtil import fmt_gath
import os

from ObjectPostProcess import postprocess_elf


def build_text_files(listing, hash_manager, verbose=False):
	has_emitted = []
	print("Assembling...")
	# Lines are already stripped, with comments and empty lines removed
	for entry in listing:
		archive_name = entry[0].split('/')[0]
		object_name = entry[0].split('/')[1]
		if archive_name not in has_emitted:
			has_emitted.append(archive_name)
			print(archive_name, end=", ")

		require_dir("./build/")

		# Output file. Base 26 for smallest path.
		dest = fmt_gath(entry[1])
		dest_path = os.path.join('./build/', dest)
		if verbose: print("entry: " + str(entry))

		if hash_manager.check(entry[0], ".\\asm\\"):
			if verbose: print("Hashed! Skipping %s %s" % entry)
		else:
			assembler = Assembler.Assembler()
			assembler.assemble('./asm/%s' % entry[0], dest_path, True) 

			# TODO: Validate success, and potentially hash options
			hash_manager.save(entry[0], ".\\asm\\")
			
			print(dest_path)
			patches = postprocess_elf(open(dest_path, 'rb'))

			source_bytes = list(open(dest_path, 'rb').read())
			for patch in patches[0]:
				assert len(patch.dest) <= patch.src_size
				for j in range(patch.src_size):
					if j >= len(patch.dest):
						c = 0
					else:
						c = ord(patch.dest[j])
					source_bytes[patch.position + j] = c

			# Patch ctor align
			nP = 0
			for p in patches[1]:
				source_bytes[p + 0] = 0
				source_bytes[p + 1] = 0
				source_bytes[p + 2] = 0
				source_bytes[p + 3] = 4
				nP += 1
				if nP > 1:
					print("Patched ctors + dtors")
			with open(dest_path, 'wb') as file:
				file.write(bytes(source_bytes))